/*
 * Copyright (c) 2020 Daniel Brall
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

{
  parserClass="eu.bradan.purebasic.PureBasicParser"
  parserUtilClass="eu.bradan.purebasic.psi.impl.PureBasicParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="PureBasic"
  psiImplClassSuffix="Impl"
  psiPackage="eu.bradan.purebasic.psi"
  psiImplPackage="eu.bradan.purebasic.psi.impl"

  elementTypeHolderClass="eu.bradan.purebasic.psi.PureBasicTypes"
  elementTypeClass="eu.bradan.purebasic.psi.PureBasicElementType"
  tokenTypeClass="eu.bradan.purebasic.psi.PureBasicTokenType"

  psiImplUtilClass="eu.bradan.purebasic.psi.impl.PureBasicPsiImplUtil"

//  tokens = [
//    SEPARATOR='regexp:[:\n]'
//    SPACE='regexp:\s+'
//
//    COMMENT='regexp:;.*'
//    INLINE_ASM='regexp:^\s*![^\r\n:]*'
//    STRING='regexp:\"([^\r\n\"]*)\"|~\"([^\r\n\\\"]+|("\\"\")|"\\"[abfnrtv\\])*\"'
//    CHARACTER="regexp:'([^\r\n\"]+|(\\')|\\[0abfnrtv\\])'"
//    KEYWORD='regexp:XOr|XIncludeFile|With|While|Wend|UseModule|UnuseModule|Until|UndefineMacro|To|Threaded|Swap|StructureUnion|Structure|Step|Static|Shared|Select|Runtime|Return|Restore|Repeat|ReDim|Read|PrototypeC|Prototype|Protected|ProcedureReturn|ProcedureDLL|ProcedureCDLL|ProcedureC|Procedure|Or|Not|Next|NewMap|NewList|Module|Map|MacroExpandedCount|Macro|List|Interface|IncludePath|IncludeFile|IncludeBinary|ImportC|Import|If|Goto|Gosub|Global|ForEver|ForEach|For|FakeReturn|Extends|EnumerationBinary|Enumeration|EndWith|EndStructureUnion|EndStructure|EndSelect|EndProcedure|EndModule|EndMacro|EndInterface|EndImport|EndIf|EndEnumeration|EndDeclareModule|EndDataSection|End|EnableJS|EnableExplicit|EnableDebugger|EnableASM|ElseIf|Else|DisableJS|DisableExplicit|DisableDebugger|DisableASM|Dim|Define|Default|DeclareModule|DeclareDLL|DeclareCDLL|DeclareC|Declare|DebugLevel|Debug|DataSection|Data|Continue|CompilerWarning|CompilerSelect|CompilerIf|CompilerError|CompilerEndSelect|CompilerEndIf|CompilerElseIf|CompilerElse|CompilerDefault|CompilerCase|Case|CallDebugger|Break|As|Array|And|Align'
//    NUMBER='regexp:\$[0-9A-Fa-f]+|%[01]+|[0-9]+(\.[0-9]+|)'
//    OPERATOR='regexp:\(|\)|[|]|<=|=<|>=|=>|<>|<<|>>|=|\+|-|\*|/|&|\||!|~|<|>|%|.|,|\\|#|::|@|\?'
//    IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z_0-9]*(\$|)'
//    POINTER_IDENTIFIER='regexp:\*[a-zA-Z_][a-zA-Z_0-9]*(\$|)'
//    CONSTANT_IDENTIFIER='regexp:#[a-zA-Z_][a-zA-Z_0-9]*(\$|)'
//  ]

  extends("simple_statement")=statement
  extends("block_statement")=statement
  extends(".*_stmt")=simple_statement
  extends(".*_block")=block_statement
}

pureBasicFile ::= [sep] statements_error_tolerant [sep]

sep ::= SEPARATOR+
private nosep ::= !sep

parse_label_identifier ::= LABEL_IDENTIFIER {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicNamedElementImpl"
            implements="eu.bradan.purebasic.psi.PureBasicNamedElement"
        }
parse_identifier ::= IDENTIFIER {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicNamedElementImpl"
            implements="eu.bradan.purebasic.psi.PureBasicNamedElement"
        }
parse_pointer_identifier ::= POINTER_IDENTIFIER {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicNamedElementImpl"
            implements="eu.bradan.purebasic.psi.PureBasicNamedElement"
        }
parse_constant_identifier ::= CONSTANT_IDENTIFIER {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicNamedElementImpl"
            implements="eu.bradan.purebasic.psi.PureBasicNamedElement"
        }

private any_keyword ::= KEYWORD_XOR |
            KEYWORD_XINCLUDEFILE |
            KEYWORD_WITH |
            KEYWORD_WHILE |
            KEYWORD_WEND |
            KEYWORD_USEMODULE |
            KEYWORD_UNUSEMODULE |
            KEYWORD_UNTIL |
            KEYWORD_UNDEFINEMACRO |
            KEYWORD_TO |
            KEYWORD_THREADED |
            KEYWORD_SWAP |
            KEYWORD_STRUCTUREUNION |
            KEYWORD_STRUCTURE |
            KEYWORD_STEP |
            KEYWORD_STATIC |
            KEYWORD_SHARED |
            KEYWORD_SELECT |
            KEYWORD_RUNTIME |
            KEYWORD_RETURN |
            KEYWORD_RESTORE |
            KEYWORD_REPEAT |
            KEYWORD_REDIM |
            KEYWORD_READ |
            KEYWORD_PROTOTYPEC |
            KEYWORD_PROTOTYPE |
            KEYWORD_PROTECTED |
            KEYWORD_PROCEDURERETURN |
            KEYWORD_PROCEDUREDLL |
            KEYWORD_PROCEDURECDLL |
            KEYWORD_PROCEDUREC |
            KEYWORD_PROCEDURE |
            KEYWORD_OR |
            KEYWORD_NOT |
            KEYWORD_NEXT |
            KEYWORD_NEWMAP |
            KEYWORD_NEWLIST |
            KEYWORD_MODULE |
            KEYWORD_MAP |
            KEYWORD_MACROEXPANDEDCOUNT |
            KEYWORD_MACRO |
            KEYWORD_LIST |
            KEYWORD_INTERFACE |
            KEYWORD_INCLUDEPATH |
            KEYWORD_INCLUDEFILE |
            KEYWORD_INCLUDEBINARY |
            KEYWORD_IMPORTC |
            KEYWORD_IMPORT |
            KEYWORD_IF |
            KEYWORD_GOTO |
            KEYWORD_GOSUB |
            KEYWORD_GLOBAL |
            KEYWORD_FOREVER |
            KEYWORD_FOREACH |
            KEYWORD_FOR |
            KEYWORD_FAKERETURN |
            KEYWORD_EXTENDS |
            KEYWORD_ENUMERATIONBINARY |
            KEYWORD_ENUMERATION |
            KEYWORD_ENDWITH |
            KEYWORD_ENDSTRUCTUREUNION |
            KEYWORD_ENDSTRUCTURE |
            KEYWORD_ENDSELECT |
            KEYWORD_ENDPROCEDURE |
            KEYWORD_ENDMODULE |
            KEYWORD_ENDMACRO |
            KEYWORD_ENDINTERFACE |
            KEYWORD_ENDIMPORT |
            KEYWORD_ENDIF |
            KEYWORD_ENDENUMERATION |
            KEYWORD_ENDDECLAREMODULE |
            KEYWORD_ENDDATASECTION |
            KEYWORD_END |
            KEYWORD_ENABLEJS |
            KEYWORD_ENABLEEXPLICIT |
            KEYWORD_ENABLEDEBUGGER |
            KEYWORD_ENABLEASM |
            KEYWORD_ELSEIF |
            KEYWORD_ELSE |
            KEYWORD_DISABLEJS |
            KEYWORD_DISABLEEXPLICIT |
            KEYWORD_DISABLEDEBUGGER |
            KEYWORD_DISABLEASM |
            KEYWORD_DIM |
            KEYWORD_DEFINE |
            KEYWORD_DEFAULT |
            KEYWORD_DECLAREMODULE |
            KEYWORD_DECLAREDLL |
            KEYWORD_DECLARECDLL |
            KEYWORD_DECLAREC |
            KEYWORD_DECLARE |
            KEYWORD_DEBUGLEVEL |
            KEYWORD_DEBUG |
            KEYWORD_DATASECTION |
            KEYWORD_DATA |
            KEYWORD_CONTINUE |
            KEYWORD_COMPILERWARNING |
            KEYWORD_COMPILERSELECT |
            KEYWORD_COMPILERIF |
            KEYWORD_COMPILERERROR |
            KEYWORD_COMPILERENDSELECT |
            KEYWORD_COMPILERENDIF |
            KEYWORD_COMPILERELSEIF |
            KEYWORD_COMPILERELSE |
            KEYWORD_COMPILERDEFAULT |
            KEYWORD_COMPILERCASE |
            KEYWORD_CASE |
            KEYWORD_CALLDEBUGGER |
            KEYWORD_BREAK |
            KEYWORD_AS |
            KEYWORD_ARRAY |
            KEYWORD_AND |
            KEYWORD_ALIGN

private any_operator ::= OP_PARENOPEN |
                 OP_PARENCLOSE |
                 OP_BRACKOPEN |
                 OP_BRACKCLOSE |
                 OP_LEQ |
                 OP_EQL |
                 OP_GEQ |
                 OP_EQG |
                 OP_NE |
                 OP_LSHIFT |
                 OP_RSHIFT |
                 OP_EQ |
                 OP_PLUS |
                 OP_MINUS |
                 OP_MUL |
                 OP_DIV |
                 OP_AND |
                 OP_OR |
                 OP_XOR |
                 OP_NOT |
                 OP_LESS |
                 OP_GREATER |
                 OP_MODULO |
                 OP_DOT |
                 OP_COMMA |
                 OP_BACKSLASH |
                 OP_HASH |
                 OP_MODULE |
                 OP_VARADDR |
                 OP_LABELADDR |
                 OP_DQUOTE |
                 OP_QUOTE

statement ::= (block_statement_|simple_statement_|INLINE_ASM|COMMENT|potentially_invalid_expression) [potentially_invalid_expression]
private block_statement_ ::= macro_head_stmt|macro_foot_stmt|procedure_head_stmt|procedure_foot_stmt|with_head_stmt|
                    with_foot_stmt|structure_head_stmt|structure_foot_stmt|structure_union_head_stmt|
                    structure_union_foot_stmt|interface_head_stmt|interface_foot_stmt|import_head_stmt|import_foot_stmt|
                    data_section_head_stmt|data_section_foot_stmt|enumeration_head_stmt|enumeration_foot_stmt|
                    declare_module_head_stmt|declare_module_foot_stmt|define_module_head_stmt|define_module_foot_stmt|
                    loops|conditions|comp_conditions
fake block_statement ::= block_statement_
private simple_statement_ ::= include_stmt|include_binary_stmt|include_path_stmt|use_module_stmt|unuse_module_stmt|
                    undefine_macro_stmt|swap_stmt|runtime_stmt|return_stmt|restore_stmt|read_stmt|prototype_stmt|
                    macro_expanded_count_stmt|goto_stmt|gosub_stmt|fake_return_stmt|end_stmt|enable_js_stmt|
                    enable_explicit_stmt|enable_debugger_stmt|enable_asm_stmt|disable_js_stmt|disable_explicit_stmt|
                    disable_debugger_stmt|disable_asm_stmt|debug_level_stmt|debug_stmt|continue_stmt|break_stmt|
                    compiler_warning_stmt|compiler_error_stmt|call_debugger_stmt|data_list_stmt|procedure_return_stmt|
                    assignment_stmt|call_stmt|label_stmt|declaration_stmt|parse_constant_identifier
fake simple_statement ::= simple_statement_;

private statements ::= statement (sep statement)*

// Error tolerant statements for the very first layer
private external always_true_statement ::= parseAlwaysTrueStatement;
private statement_error_tolerant ::= always_true_statement [statement] {pin=1 recoverWhile=nosep}
private statements_error_tolerant ::= statement_error_tolerant (sep statement_error_tolerant)*

pseudo_types ::= 'p' OP_MINUS ('unicode'|'ascii'|'utf8'|'bstr'|'variant')
type_suffix ::= OP_DOT (pseudo_types|[module_path] parse_identifier)
static_array_access ::= OP_BRACKOPEN expression OP_BRACKCLOSE

label_stmt ::= parse_label_identifier ':'


// Assignment
unary_operators ::= OP_MINUS|OP_XOR|OP_NOT|KEYWORD_NOT|OP_VARADDR|OP_LABELADDR
binary_operators ::= OP_LEQ|OP_EQL|OP_GEQ|OP_EQG|OP_NE|OP_LSHIFT|OP_RSHIFT|OP_EQ|OP_PLUS[sep]|OP_MINUS|OP_MUL|OP_DIV|
                     OP_AND|OP_OR[sep]|OP_XOR|OP_NOT|OP_LESS|OP_GREATER|OP_MODULO|OP_HASH|
                     KEYWORD_AND[sep]|KEYWORD_OR[sep]|KEYWORD_XOR[sep]|KEYWORD_AS
enclosing_operators ::= OP_DQUOTE|OP_QUOTE|OP_PARENOPEN|OP_PARENCLOSE|OP_BRACKOPEN|OP_BRACKCLOSE

private assign_target ::= (identifier_or_call_chained|parse_pointer_identifier) [type_suffix [static_array_access]] | parse_constant_identifier
assignment_stmt ::= assign_target (OP_EQ|OP_PLUS[sep]|OP_MINUS|OP_MUL|OP_DIV|OP_AND|OP_OR|OP_XOR|OP_MODULO) expression

expression ::= OP_PARENOPEN expression OP_PARENCLOSE (binary_operators expression)? |
                (identifier_or_call_chained|atom) binary_operators expression |
                 unary_operators expression |
                (identifier_or_call_chained|atom) expression | // for macro usage
                (identifier_or_call_chained|atom)
potentially_invalid_expression ::= (identifier_or_call_chained|atom|any_operator|any_keyword)+

module_path_element ::= parse_identifier
module_path ::= [OP_MODULE] (module_path_element OP_MODULE)*
structure_path_element ::= parse_identifier [static_array_access]|parse_pointer_identifier|call
structure_path ::= [OP_BACKSLASH] (structure_path_element OP_BACKSLASH)*
private meta chained ::= [module_path] [structure_path] <<param>>
identifier_chained ::= <<chained (parse_identifier [type_suffix] [static_array_access])>>
call_chained ::= <<chained call>>
private identifier_or_call_chained ::= call_chained | identifier_chained

atom ::= NUMBER|parse_constant_identifier|parse_identifier|parse_pointer_identifier|CHARACTER|STRING

// Declarations
declaration_stmt ::= import_function_declaration|variable_declaration|array_declaration|list_declaration|map_declaration|procedure_declaration
declaration_scope ::= KEYWORD_GLOBAL|KEYWORD_SHARED|KEYWORD_PROTECTED|KEYWORD_STATIC|KEYWORD_THREADED|KEYWORD_DEFINE

variable_decl_identifier ::= (parse_identifier|parse_pointer_identifier) [type_suffix]
variable_decl_identifier_notype ::= (parse_identifier|parse_pointer_identifier)
variable_decl_list ::= variable_decl_identifier [OP_EQ expression] (OP_COMMA [sep] variable_decl_identifier [OP_EQ expression])*
variable_decl_list_notype ::= variable_decl_identifier_notype (OP_COMMA [sep] variable_decl_identifier_notype)*
variable_declaration ::= declaration_scope type_suffix variable_decl_list_notype |
    declaration_scope variable_decl_list |
    variable_decl_identifier [static_array_access]

array_declaration ::= [declaration_scope] (KEYWORD_DIM|KEYWORD_REDIM) parse_identifier [type_suffix] OP_PARENOPEN parameters_call OP_PARENCLOSE
list_declaration ::= [declaration_scope] KEYWORD_NEWLIST parse_identifier [type_suffix] OP_PARENOPEN OP_PARENCLOSE
map_declaration ::= [declaration_scope] KEYWORD_NEWMAP parse_identifier [type_suffix] OP_PARENOPEN OP_PARENCLOSE

// Import functions
import_function_declaration ::= parse_identifier [type_suffix] OP_PARENOPEN [parameters_decl] OP_PARENCLOSE [KEYWORD_AS expression]


////////////////////////
// Blocks
////////////////////////

// Procedure
private procedure_decl_pattern ::= [type_suffix] parse_identifier OP_PARENOPEN [parameters_decl] OP_PARENCLOSE
procedure_declaration ::= (KEYWORD_DECLARECDLL|KEYWORD_DECLAREDLL|KEYWORD_DECLAREC|KEYWORD_DECLARE) procedure_decl_pattern

private parameters_decl_var ::= (parse_identifier|parse_pointer_identifier) [type_suffix] [OP_EQ expression]
private parameters_decl_array ::= KEYWORD_ARRAY parse_identifier [type_suffix] OP_PARENOPEN NUMBER OP_PARENCLOSE
private parameters_decl_list ::= KEYWORD_LIST parse_identifier [type_suffix] OP_PARENOPEN OP_PARENCLOSE
private parameters_decl_map ::= KEYWORD_MAP parse_identifier [type_suffix] OP_PARENOPEN OP_PARENCLOSE
parameters_decl ::= (parameters_decl_var | parameters_decl_array | parameters_decl_list | parameters_decl_map)
                    (OP_COMMA [sep] (parameters_decl_var | parameters_decl_array | parameters_decl_list | parameters_decl_map))*
parameters_call ::= expression (OP_COMMA [sep] expression)*

procedure_head_stmt ::= (KEYWORD_PROCEDURECDLL | KEYWORD_PROCEDUREDLL | KEYWORD_PROCEDUREC | KEYWORD_PROCEDURE) procedure_decl_pattern
procedure_return_stmt ::= KEYWORD_PROCEDURERETURN [expression]
procedure_foot_stmt ::= KEYWORD_ENDPROCEDURE

// Macro
macro_parameter_decl ::= parse_identifier [OP_EQ [expression]]
macro_parameter_decl_list ::= macro_parameter_decl (OP_COMMA [sep] macro_parameter_decl)*
private macro_decl_pattern ::= [type_suffix] parse_identifier [OP_PARENOPEN [macro_parameter_decl_list] OP_PARENCLOSE]

macro_head_stmt ::= KEYWORD_MACRO macro_decl_pattern
macro_foot_stmt ::= KEYWORD_ENDMACRO

// With
with_head_stmt ::= KEYWORD_WITH identifier_or_call_chained
with_foot_stmt ::= KEYWORD_ENDWITH

// A call (macro or procedure, something with parenthesis)
call ::= parse_identifier OP_PARENOPEN [parameters_call] OP_PARENCLOSE
call_stmt ::= call_chained [KEYWORD_AS]

// Structure
structure_head_stmt ::= KEYWORD_STRUCTURE parse_identifier
                        [KEYWORD_EXTENDS parse_identifier]
                        [KEYWORD_ALIGN (NUMBER|parse_constant_identifier)]
structure_foot_stmt ::= KEYWORD_ENDSTRUCTURE

structure_union_head_stmt ::= KEYWORD_STRUCTUREUNION
structure_union_foot_stmt ::= KEYWORD_ENDSTRUCTUREUNION

// Interface
interface_head_stmt ::= KEYWORD_INTERFACE parse_identifier [KEYWORD_EXTENDS parse_identifier]
interface_foot_stmt ::= KEYWORD_ENDINTERFACE

// Import
import_head_stmt ::= (KEYWORD_IMPORT|KEYWORD_IMPORTC) expression
import_foot_stmt ::= KEYWORD_ENDIMPORT

// DataSection
data_entry ::= parse_constant_identifier|NUMBER|STRING
data_list_stmt ::= KEYWORD_DATA [type_suffix] data_entry (OP_COMMA [sep] data_entry)*

data_section_head_stmt ::= KEYWORD_DATASECTION
data_section_foot_stmt ::= KEYWORD_ENDDATASECTION

// DeclareModule
declare_module_head_stmt ::= KEYWORD_DECLAREMODULE parse_identifier
declare_module_foot_stmt ::= KEYWORD_ENDDECLAREMODULE

// Module
define_module_head_stmt ::= KEYWORD_MODULE parse_identifier
define_module_foot_stmt ::= KEYWORD_ENDMODULE

// Enumeration
enumeration_head_stmt ::= (KEYWORD_ENUMERATION | KEYWORD_ENUMERATIONBINARY) [parse_identifier]
enumeration_foot_stmt ::= KEYWORD_ENDENUMERATION

// Loops
while_head_stmt ::= KEYWORD_WHILE expression
while_foot_stmt ::= KEYWORD_WEND
for_head_stmt ::= KEYWORD_FOR variable_decl_identifier OP_EQ expression KEYWORD_TO expression [KEYWORD_STEP NUMBER]
for_foot_stmt ::= KEYWORD_NEXT [parse_identifier]
foreach_head_stmt ::= KEYWORD_FOREACH identifier_or_call_chained
foreach_foot_stmt ::= KEYWORD_NEXT
repeat_head_stmt ::= KEYWORD_REPEAT
repeat_foot_stmt ::= (KEYWORD_UNTIL expression | KEYWORD_FOREVER)

private loops ::= while_head_stmt|while_foot_stmt|
                    for_head_stmt|for_foot_stmt|
                    foreach_head_stmt|foreach_foot_stmt|
                    repeat_head_stmt|repeat_foot_stmt

// Conditional
condition_if_stmt ::= KEYWORD_IF expression
condition_elseif_stmt ::= KEYWORD_ELSEIF expression
condition_else_stmt ::= KEYWORD_ELSE
condition_endif_stmt ::= KEYWORD_ENDIF

// Case 1
// Case 1, 10
// Case 2 , 3 , 4
// Case 15 To 20, 30, 40 To 50
condition_case_stmt ::= KEYWORD_CASE (expression [KEYWORD_TO expression] [(',' expression [KEYWORD_TO expression])+])|
                        KEYWORD_DEFAULT
condition_select_stmt ::= KEYWORD_SELECT expression
condition_endselect_stmt ::= KEYWORD_ENDSELECT

private conditions ::= condition_if_stmt|condition_elseif_stmt|condition_else_stmt|condition_endif_stmt|
                       condition_select_stmt|condition_endselect_stmt|condition_case_stmt

// Compiler Conditional
comp_condition_if_stmt ::= KEYWORD_COMPILERIF expression
comp_condition_elseif_stmt ::= KEYWORD_COMPILERELSEIF expression
comp_condition_else_stmt ::= KEYWORD_COMPILERELSE
comp_condition_endif_stmt ::= KEYWORD_COMPILERENDIF

comp_condition_case_stmt ::= KEYWORD_COMPILERCASE expression|KEYWORD_COMPILERDEFAULT
comp_condition_select_stmt ::= KEYWORD_COMPILERSELECT expression
comp_condition_endselect_stmt ::= KEYWORD_COMPILERENDSELECT

private comp_conditions ::= comp_condition_if_stmt|comp_condition_elseif_stmt|comp_condition_else_stmt|comp_condition_endif_stmt|
                            comp_condition_select_stmt|comp_condition_endselect_stmt|comp_condition_case_stmt

////////////////////////
// Simple Statements
////////////////////////

include_stmt ::= (KEYWORD_XINCLUDEFILE|KEYWORD_INCLUDEFILE) STRING {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicIncludeElement"
        }
include_binary_stmt ::= KEYWORD_INCLUDEBINARY STRING {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicIncludeElement"
        }
include_path_stmt ::= KEYWORD_INCLUDEPATH STRING {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicIncludeElement"
        }
use_module_stmt ::= KEYWORD_USEMODULE parse_identifier
unuse_module_stmt ::= KEYWORD_UNUSEMODULE parse_identifier
undefine_macro_stmt ::= KEYWORD_UNDEFINEMACRO parse_identifier
swap_stmt ::= KEYWORD_SWAP identifier_or_call_chained OP_COMMA [sep] identifier_or_call_chained
runtime_stmt ::= KEYWORD_RUNTIME (procedure_head_stmt|enumeration_head_stmt|parse_constant_identifier|parse_identifier|parse_pointer_identifier)
return_stmt ::= KEYWORD_RETURN
restore_stmt ::= KEYWORD_RESTORE parse_identifier
read_stmt ::= KEYWORD_READ [type_suffix] parse_identifier
prototype_stmt ::= (KEYWORD_PROTOTYPEC|KEYWORD_PROTOTYPE) procedure_decl_pattern
macro_expanded_count_stmt ::= KEYWORD_MACROEXPANDEDCOUNT
goto_stmt ::= KEYWORD_GOTO parse_identifier
gosub_stmt ::= KEYWORD_GOSUB parse_identifier
fake_return_stmt ::= KEYWORD_FAKERETURN
end_stmt ::= KEYWORD_END expression
enable_js_stmt ::= KEYWORD_ENABLEJS
enable_explicit_stmt ::= KEYWORD_ENABLEEXPLICIT
enable_debugger_stmt ::= KEYWORD_ENABLEDEBUGGER
enable_asm_stmt ::= KEYWORD_ENABLEASM
disable_js_stmt ::= KEYWORD_DISABLEJS
disable_explicit_stmt ::= KEYWORD_DISABLEEXPLICIT
disable_debugger_stmt ::= KEYWORD_DISABLEDEBUGGER
disable_asm_stmt ::= KEYWORD_DISABLEASM
debug_level_stmt ::= KEYWORD_DEBUGLEVEL (parse_constant_identifier|NUMBER)
debug_stmt ::= KEYWORD_DEBUG expression [OP_COMMA [sep] (parse_constant_identifier|NUMBER)]
continue_stmt ::= KEYWORD_CONTINUE
break_stmt ::= KEYWORD_BREAK
compiler_warning_stmt ::= KEYWORD_COMPILERWARNING (parse_constant_identifier|STRING)
compiler_error_stmt ::= KEYWORD_COMPILERERROR (parse_constant_identifier|STRING)
call_debugger_stmt ::= KEYWORD_CALLDEBUGGER

////////////////////////
// Misc
////////////////////////

//noinspection BnfUnusedRule
private leftTokens ::= KEYWORD|OPERATOR
// private tokenTypes_ ::= COMMENT|KEYWORD|OPERATOR|STRING|CHARACTER|CONSTANT_IDENTIFIER|NUMBER|IDENTIFIER|POINTER_IDENTIFIER
