/*
 * Copyright (c) 2020 Daniel Brall
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

{
  parserClass="eu.bradan.purebasic.PureBasicParser"
  parserUtilClass="eu.bradan.purebasic.psi.impl.PureBasicParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="PureBasic"
  psiImplClassSuffix="Impl"
  psiPackage="eu.bradan.purebasic.psi"
  psiImplPackage="eu.bradan.purebasic.psi.impl"

  elementTypeHolderClass="eu.bradan.purebasic.psi.PureBasicTypes"
  elementTypeClass="eu.bradan.purebasic.psi.PureBasicElementType"
  tokenTypeClass="eu.bradan.purebasic.psi.PureBasicTokenType"

  psiImplUtilClass="eu.bradan.purebasic.psi.impl.PureBasicPsiImplUtil"

//  tokens = [
//    SEPARATOR='regexp:[:\n]'
//    SPACE='regexp:\s+'
//
//    COMMENT='regexp:;.*'
//    INLINE_ASM='regexp:^\s*![^\r\n:]*'
//    STRING='regexp:\"([^\r\n\"]*)\"|~\"([^\r\n\\\"]+|("\\"\")|"\\"[abfnrtv\\])*\"'
//    CHARACTER="regexp:'([^\r\n\"]+|(\\')|\\[0abfnrtv\\])'"
//    KEYWORD='regexp:XOr|XIncludeFile|With|While|Wend|UseModule|UnuseModule|Until|UndefineMacro|To|Threaded|Swap|StructureUnion|Structure|Step|Static|Shared|Select|Runtime|Return|Restore|Repeat|ReDim|Read|PrototypeC|Prototype|Protected|ProcedureReturn|ProcedureDLL|ProcedureCDLL|ProcedureC|Procedure|Or|Not|Next|NewMap|NewList|Module|Map|MacroExpandedCount|Macro|List|Interface|IncludePath|IncludeFile|IncludeBinary|ImportC|Import|If|Goto|Gosub|Global|ForEver|ForEach|For|FakeReturn|Extends|EnumerationBinary|Enumeration|EndWith|EndStructureUnion|EndStructure|EndSelect|EndProcedure|EndModule|EndMacro|EndInterface|EndImport|EndIf|EndEnumeration|EndDeclareModule|EndDataSection|End|EnableJS|EnableExplicit|EnableDebugger|EnableASM|ElseIf|Else|DisableJS|DisableExplicit|DisableDebugger|DisableASM|Dim|Define|Default|DeclareModule|DeclareDLL|DeclareCDLL|DeclareC|Declare|DebugLevel|Debug|DataSection|Data|Continue|CompilerWarning|CompilerSelect|CompilerIf|CompilerError|CompilerEndSelect|CompilerEndIf|CompilerElseIf|CompilerElse|CompilerDefault|CompilerCase|Case|CallDebugger|Break|As|Array|And|Align'
//    NUMBER='regexp:\$[0-9A-Fa-f]+|%[01]+|[0-9]+(\.[0-9]+|)'
//    OPERATOR='regexp:\(|\)|[|]|<=|=<|>=|=>|<>|<<|>>|=|\+|-|\*|/|&|\||!|~|<|>|%|.|,|\\|#|::|@|\?'
//    IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z_0-9]*(\$|)'
//    POINTER_IDENTIFIER='regexp:\*[a-zA-Z_][a-zA-Z_0-9]*(\$|)'
//    CONSTANT_IDENTIFIER='regexp:#[a-zA-Z_][a-zA-Z_0-9]*(\$|)'
//  ]

  extends("simple_statement")=statement
  extends("block_statement")=statement
  extends(".*_stmt")=simple_statement
  extends(".*_block")=block_statement
}

pureBasicFile ::= [sep] statements_error_tolerant [sep]

sep ::= SEPARATOR+
private nosep ::= !sep

parse_label_identifier ::= LABEL_IDENTIFIER {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicNamedElementImpl"
            implements="eu.bradan.purebasic.psi.PureBasicNamedElement"
        }
parse_identifier ::= IDENTIFIER {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicNamedElementImpl"
            implements="eu.bradan.purebasic.psi.PureBasicNamedElement"
        }
parse_pointer_identifier ::= POINTER_IDENTIFIER {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicNamedElementImpl"
            implements="eu.bradan.purebasic.psi.PureBasicNamedElement"
        }
parse_constant_identifier ::= CONSTANT_IDENTIFIER {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicNamedElementImpl"
            implements="eu.bradan.purebasic.psi.PureBasicNamedElement"
        }

statement ::= simple_statement_|block_statement_|INLINE_ASM|COMMENT
private block_statement_ ::= macro_block|comp_condition_block|procedure_block|with_block|structure_block|interface_block|
                    import_block|data_section_block|enumeration_block|declare_module_block|define_module_block|
                    loop_block|condition_block|structure_union_block
fake block_statement ::= block_statement_
private simple_statement_ ::= include_stmt|include_binary_stmt|include_path_stmt|use_module_stmt|unuse_module_stmt|
                    undefine_macro_stmt|swap_stmt|runtime_stmt|return_stmt|restore_stmt|read_stmt|prototype_stmt|
                    macro_expanded_count_stmt|goto_stmt|gosub_stmt|fake_return_stmt|end_stmt|enable_js_stmt|
                    enable_explicit_stmt|enable_debugger_stmt|enable_asm_stmt|disable_js_stmt|disable_explicit_stmt|
                    disable_debugger_stmt|disable_asm_stmt|debug_level_stmt|debug_stmt|continue_stmt|break_stmt|
                    compiler_warning_stmt|compiler_error_stmt|call_debugger_stmt|data_list_stmt|procedure_return_stmt|
                    assignment_stmt|call_stmt|declaration_stmt|label_stmt|parse_constant_identifier
fake simple_statement ::= simple_statement_;

private statements ::= statement (sep statement)*

// Error tolerant statements for the very first layer
private external always_true_statement ::= parseAlwaysTrueStatement;
private statement_error_tolerant ::= always_true_statement [statement] {pin=1 recoverWhile=nosep}
private statements_error_tolerant ::= statement_error_tolerant (sep statement_error_tolerant)*

pseudo_types ::= 'p' '-' ('unicode'|'ascii'|'utf8'|'bstr'|'variant')
type_suffix ::= '.' (pseudo_types|[module_path] parse_identifier)
static_array_access ::= '[' expression ']'

label_stmt ::= parse_label_identifier ':'


// Assignment
unary_operators ::= '-'|'!'|'~'|'Not'|'@'|'?'
binary_operators ::= '<='|'=<'|'>='|'=>'|'<>'|'<<'|'>>'|'='|'+'[sep]|'-'|'*'|'/'|'&'|'|'[sep]|'!'|'~'|'<'|'>'|'%'|'#'|'And'[sep]|'Or'[sep]|'XOr'[sep]

private assign_target ::= (identifier_or_call_chained|parse_pointer_identifier) [type_suffix [static_array_access]] | parse_constant_identifier
assignment_stmt ::= assign_target ('='|'+'|'-'|'*'|'/') expression {pin=2}

expression ::= '(' expression ')' |
                (identifier_or_call_chained|atom) binary_operators expression |
                 unary_operators expression |
                (identifier_or_call_chained|atom)

module_path_element ::= parse_identifier
module_path ::= ['::'] (module_path_element '::')*
structure_path_element ::= parse_identifier [static_array_access]|parse_pointer_identifier|call_stmt
structure_path ::= ['\'] (structure_path_element '\')*
identifier_chained ::= [module_path] [structure_path] parse_identifier [static_array_access]
call_chained ::= [module_path] [structure_path] call_stmt
private identifier_or_call_chained ::= call_chained | identifier_chained

atom ::= NUMBER|parse_constant_identifier|parse_identifier|parse_pointer_identifier|CHARACTER|STRING

// Declarations
declaration_stmt ::= variable_declaration|array_declaration|list_declaration|map_declaration|procedure_declaration
declaration_scope ::= 'Global'|'Shared'|'Protected'|'Static'|'Threaded'|'Define'

variable_decl_identifier ::= (parse_identifier|parse_pointer_identifier) [type_suffix]
variable_decl_identifier_notype ::= (parse_identifier|parse_pointer_identifier)
variable_decl_list ::= variable_decl_identifier ['=' expression] (',' [sep] variable_decl_identifier ['=' expression])*
variable_decl_list_notype ::= variable_decl_identifier_notype (',' [sep] variable_decl_identifier_notype)*
variable_declaration ::= declaration_scope type_suffix variable_decl_list_notype |
    declaration_scope variable_decl_list |
    variable_decl_identifier [static_array_access]

array_declaration ::= [declaration_scope] ('Dim'|'ReDim') parse_identifier [type_suffix] '(' parameters_call ')'
list_declaration ::= [declaration_scope] 'NewList' parse_identifier [type_suffix] '(' ')'
map_declaration ::= [declaration_scope] 'NewMap' parse_identifier [type_suffix] '(' ')'



////////////////////////
// Blocks
////////////////////////

// Procedure
private procedure_decl_pattern ::= [type_suffix] parse_identifier '(' [parameters_decl] ')'
procedure_declaration ::= ('DeclareC'|'Declare') procedure_decl_pattern {pin=1}

procedure_block ::= procedure_start procedure_foot {pin=1 methods=[getPresentation]}

private parameters_decl_var ::= (parse_identifier|parse_pointer_identifier) [type_suffix] ['=' expression]
private parameters_decl_array ::= 'Array' parse_identifier [type_suffix] '(' NUMBER ')' {pin=1}
private parameters_decl_list ::= 'List' parse_identifier [type_suffix] '(' ')' {pin=1}
private parameters_decl_map ::= 'Map' parse_identifier [type_suffix] '(' ')' {pin=1}
parameters_decl ::= (parameters_decl_var | parameters_decl_array | parameters_decl_list | parameters_decl_map) [',' [sep] parameters_decl]
parameters_call ::= expression (',' [sep] expression)*

private procedure_start ::= procedure_head [sep statements] sep {pin=1 recoverWhile=no_procedure_foot}
procedure_head ::= ('ProcedureCDLL' | 'ProcedureDLL' | 'ProcedureC' | 'Procedure') procedure_decl_pattern {pin=1 recoverWhile=nosep}
procedure_return_stmt ::= 'ProcedureReturn' [expression]
procedure_foot ::= 'EndProcedure'
private no_procedure_foot ::= !procedure_foot

// Macro
macro_parameter_decl ::= parse_identifier ['=' [expression]]
macro_parameter_decl_list ::= macro_parameter_decl (',' [sep] macro_parameter_decl)*
private macro_decl_pattern ::= [type_suffix] parse_identifier ['(' [macro_parameter_decl_list] ')']

macro_block ::= macro_start macro_foot {pin=1 methods=[getPresentation]}

private macro_start ::= macro_head [sep (expression | statements)] sep {pin=1 recoverWhile=no_macro_foot}
macro_head ::= 'Macro' macro_decl_pattern {pin=1 recoverWhile=nosep}
macro_foot ::= 'EndMacro'
private no_macro_foot ::= !macro_foot

// With
with_block ::= with_start sep with_foot

private with_start ::= with_head [sep statements] sep {pin=1 recoverWhile=no_with_foot}
with_head ::= 'With' identifier_or_call_chained {pin=1 recoverWhile=nosep}
with_foot ::= 'EndWith'
private no_with_foot ::= !with_foot


call_stmt ::= parse_identifier '(' [parameters_call] ')'

// Structure
structure_block ::= structure_start structure_foot {pin=1 methods=[getPresentation]}

private structure_start ::= structure_head [sep statements] sep {pin=1 recoverWhile=no_structure_foot}
structure_head ::= 'Structure' parse_identifier ['Extends' parse_identifier] ['Align' (NUMBER|parse_constant_identifier)] {pin=1 recoverWhile=nosep}
structure_foot ::= 'EndStructure'
private no_structure_foot ::= !structure_foot

structure_union_block ::= structure_union_start structure_union_foot {pin=1}

private structure_union_start ::= structure_union_head [sep statements] sep {pin=1 recoverWhile=no_structure_union_foot}
structure_union_head ::= 'StructureUnion' {pin=1 recoverWhile=nosep}
structure_union_foot ::= 'EndStructureUnion'
private no_structure_union_foot ::= !structure_union_foot

// Interface
interface_block ::= interface_start interface_foot {pin=1 methods=[getPresentation]}

private interface_start ::= interface_head [sep statements] sep {pin=1 recoverWhile=no_interface_foot}
interface_head ::= 'Interface' parse_identifier ['Extends' parse_identifier] {pin=1 recoverWhile=nosep}
interface_foot ::= 'EndInterface'
private no_interface_foot ::= !interface_foot

// Import
import_block ::= import_start import_foot {pin=1}

private import_start ::= import_head [sep statements] sep {pin=1 recoverWhile=no_import_foot}
import_head ::= ('Import'|'ImportC') STRING {pin=1 recoverWhile=nosep}
import_foot ::= 'EndImport'
private no_import_foot ::= !import_foot

// DataSection
data_section_block ::= data_section_start data_section_foot {pin=1}

data_entry ::= parse_constant_identifier|NUMBER|STRING
data_list_stmt ::= 'Data' [type_suffix] data_entry (',' [sep] data_entry)*

private data_section_start ::= data_section_head [sep statements] sep {pin=1 recoverWhile=no_data_section_foot}
data_section_head ::= 'DataSection' {pin=1 recoverWhile=nosep}
data_section_foot ::= 'EndDataSection'
private no_data_section_foot ::= !data_section_foot

// DeclareModule
declare_module_block ::= declare_module_start declare_module_foot {pin=1 methods=[getPresentation]}

private declare_module_start ::= declare_module_head [sep statements] sep {pin=1 recoverWhile=no_declare_module_foot}
declare_module_head ::= 'DeclareModule' parse_identifier {pin=1 recoverWhile=nosep}
declare_module_foot ::= 'EndDeclareModule'
private no_declare_module_foot ::= !declare_module_foot

// Module
define_module_block ::= define_module_start define_module_foot {pin=1 methods=[getPresentation]}

private define_module_start ::= define_module_head [sep statements] sep {pin=1 recoverWhile=no_define_module_foot}
define_module_head ::= 'Module' parse_identifier {pin=1 recoverWhile=nosep}
define_module_foot ::= 'EndModule'
private no_define_module_foot ::= !define_module_foot

// Enumeration
enumeration_block ::= enumeration_start enumeration_foot {pin=1}

private enumeration_start ::= enumeration_head [sep statements] sep {pin=1 recoverWhile=no_enumeration_foot}
enumeration_head ::= ('Enumeration' | 'EnumerationBinary') [parse_identifier] {pin=1 recoverWhile=nosep}
enumeration_foot ::= 'EndEnumeration'
private no_enumeration_foot ::= !enumeration_foot


// Loops
private while ::= while_start while_foot {pin=1}
private while_start ::= while_head [sep statements] sep {pin=1 recoverWhile=no_while_foot}
private while_head ::= 'While' expression {pin=1 recoverWhile=nosep}
private while_foot ::= 'Wend'
private no_while_foot ::= !while_foot
private for ::= for_start for_foot {pin=1}
private for_start ::= for_head [sep statements] sep {pin=1 recoverWhile=no_for_foot}
private for_head ::= 'For' variable_decl_identifier '=' expression 'To' expression ['Step' NUMBER] {pin=1 recoverWhile=nosep}
private for_foot ::= 'Next' [parse_identifier]
private no_for_foot ::= !for_foot
private foreach ::= foreach_start foreach_foot {pin=1}
private foreach_start ::= foreach_head [sep statements] sep {pin=1 recoverWhile=no_foreach_foot}
private foreach_head ::= 'ForEach' identifier_or_call_chained {pin=1 recoverWhile=nosep}
private foreach_foot ::= 'Next'
private no_foreach_foot ::= !foreach_foot
private repeat ::= 'Repeat' [sep statements] sep ('Until' expression | 'ForEver') {pin=1}

loop_block ::= while|for|foreach|repeat

// Conditional
private condition_if ::= 'If' expression [sep statements] {pin=1}
private condition_elseif ::= 'ElseIf' expression [sep statements] {pin=1}
private condition_else ::= 'Else' [sep statements] {pin=1}
private condition_endif ::= 'EndIf'

private condition_case ::= ('Case' expression|'Default') [sep statements]
private condition_select ::= 'Select' expression (sep condition_case)* sep condition_endselect {pin=1}
private condition_endselect ::= 'EndSelect'

condition_block ::= condition_if (sep condition_elseif)* [sep condition_else] sep condition_endif | condition_select

// Compiler Conditional
private comp_condition_if ::= 'CompilerIf' expression [sep statements] {pin=1}
private comp_condition_elseif ::= 'CompilerElseIf' expression [sep statements] {pin=1}
private comp_condition_else ::= 'CompilerElse' [sep statements] {pin=1}
private comp_condition_endif ::= 'CompilerEndIf'

private comp_condition_case ::= ('CompilerCase' expression|'CompilerDefault') [sep statements] {pin=1}
private comp_condition_select ::= 'CompilerSelect' expression (sep comp_condition_case)* sep comp_condition_endselect {pin=1}
private comp_condition_endselect ::= 'CompilerEndSelect'

comp_condition_block ::= comp_condition_if (sep comp_condition_elseif)* [sep comp_condition_else] sep comp_condition_endif |
                   comp_condition_select

////////////////////////
// Simple Statements
////////////////////////

include_stmt ::= ('XIncludeFile'|'IncludeFile') STRING {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicIncludeElement"
        }
include_binary_stmt ::= 'IncludeBinary' STRING {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicIncludeElement"
        }
include_path_stmt ::= 'IncludePath' STRING {
            mixin="eu.bradan.purebasic.psi.impl.PureBasicIncludeElement"
        }
use_module_stmt ::= 'UseModule' parse_identifier {pin=1}
unuse_module_stmt ::= 'UnuseModule' parse_identifier {pin=1}
undefine_macro_stmt ::= 'UndefineMacro' parse_identifier {pin=1}
swap_stmt ::= 'Swap' identifier_or_call_chained ',' [sep] identifier_or_call_chained {pin=1}
runtime_stmt ::= 'Runtime' (parse_constant_identifier|parse_identifier|parse_pointer_identifier|procedure_block|enumeration_block) {pin=1}
return_stmt ::= 'Return'
restore_stmt ::= 'Restore' parse_identifier {pin=1}
read_stmt ::= 'Read' [type_suffix] parse_identifier {pin=1}
prototype_stmt ::= ('PrototypeC'|'Prototype') procedure_decl_pattern {pin=1}
macro_expanded_count_stmt ::= 'MacroExpandedCount'
goto_stmt ::= 'Goto' parse_identifier {pin=1}
gosub_stmt ::= 'Gosub' parse_identifier {pin=1}
fake_return_stmt ::= 'FakeReturn'
end_stmt ::= 'End' expression {pin=1}
enable_js_stmt ::= 'EnableJS'
enable_explicit_stmt ::= 'EnableExplicit'
enable_debugger_stmt ::= 'EnableDebugger'
enable_asm_stmt ::= 'EnableASM'
disable_js_stmt ::= 'DisableJS'
disable_explicit_stmt ::= 'DisableExplicit'
disable_debugger_stmt ::= 'DisableDebugger'
disable_asm_stmt ::= 'DisableASM'
debug_level_stmt ::= 'DebugLevel' (parse_constant_identifier|NUMBER) {pin=1}
debug_stmt ::= 'Debug' expression [',' [sep] (parse_constant_identifier|NUMBER)] {pin=1}
continue_stmt ::= 'Continue'
break_stmt ::= 'Break'
compiler_warning_stmt ::= 'CompilerWarning' (parse_constant_identifier|STRING) {pin=1}
compiler_error_stmt ::= 'CompilerError' (parse_constant_identifier|STRING) {pin=1}
call_debugger_stmt ::= 'CallDebugger'

////////////////////////
// Misc
////////////////////////

//noinspection BnfUnusedRule
private leftTokens ::= KEYWORD|OPERATOR
// private tokenTypes_ ::= COMMENT|KEYWORD|OPERATOR|STRING|CHARACTER|CONSTANT_IDENTIFIER|NUMBER|IDENTIFIER|POINTER_IDENTIFIER
