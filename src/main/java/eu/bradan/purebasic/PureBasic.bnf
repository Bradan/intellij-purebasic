/*
 * Copyright (c) 2020 Daniel Brall
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

{
  parserClass="eu.bradan.purebasic.PureBasicParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="PureBasic"
  psiImplClassSuffix="Impl"
  psiPackage="eu.bradan.purebasic.psi"
  psiImplPackage="eu.bradan.purebasic.psi.impl"

  elementTypeHolderClass="eu.bradan.purebasic.psi.PureBasicTypes"
  elementTypeClass="eu.bradan.purebasic.psi.PureBasicElementType"
  tokenTypeClass="eu.bradan.purebasic.psi.PureBasicTokenType"

  psiImplUtilClass="eu.bradan.purebasic.psi.impl.PureBasicPsiImplUtil"
}

pureBasicFile ::= [sep] statements [sep]

sep ::= SEPARATOR*

statement ::= simple_statement|block_statement|INLINE_ASM|COMMENT
block_statement ::= macro|comp_condition|procedure|with|structure|interface|import|datasection|
                    enumeration|declaremodule|definemodule|loop|condition
simple_statement ::= include|includebinary|includepath|usemodule|unusemodule|undefinemacro|swap|runtime|return|restore|
                     read|prototype|macroexpandedcount|goto|gosub|fakereturn|end|enablejs|enableexplicit|enabledebugger|
                     enableasm|disablejs|disableexplicit|disabledebugger|disableasm|debuglevel|debug|continue|break|
                     compilerwarning|compilererror|calldebugger|dataentry|procedurereturn|assignment|call|declaration|
                     label

statements ::= statement (sep statement)*

private any_identifier ::= CONSTANT|IDENTIFIER|POINTER_IDENTIFIER
pseudo_types ::= 'p' '-' ('unicode'|'ascii'|'utf8'|'bstr'|'variant')
type_suffix ::= '.' (pseudo_types|IDENTIFIER)

label ::= LABEL_IDENTIFIER ':'

identifier_list ::= IDENTIFIER (',' IDENTIFIER)*


// Assignment
unary_operators ::= '-'|'!'|'~'|'Not'
binary_operators ::= '<='|'=<'|'>='|'=>'|'<>'|'<<'|'>>'|'='|'+'|'-'|'*'|'/'|'&'|'|'|'!'|'~'|'<'|'>'|'%'|'And'|'Or'|'XOr'

assignment ::= (identifier_or_call_chained [type_suffix]|CONSTANT) ('='|'+'|'-'|'*'|'/') expression

expression ::= '(' expression ')' |
                (identifier_or_call_chained|atom) binary_operators expression |
                 unary_operators expression |
                (identifier_or_call_chained|atom)

module ::= (IDENTIFIER '::')+
private any_identifier_or_call ::= call|IDENTIFIER|POINTER_IDENTIFIER
private identifier_or_call ::= call|IDENTIFIER
private identifier_or_call_chained ::= ['\'|module|any_identifier_or_call'\'] (identifier_or_call '\')* identifier_or_call
atom ::= NUMBER|any_identifier|CHARACTER|STRING

// Declarations
declaration ::= variable_declaration|array_declaration|list_declaration|map_declaration|procedure_declaration
declaration_scope ::= 'Global'|'Shared'|'Protected'|'Static'|'Threaded'|'Define'

private variable_decl_pattern ::= any_identifier [type_suffix]
variable_decl_list ::= variable_decl_pattern ['=' expression] [',' variable_decl_list]
variable_declaration ::= declaration_scope type_suffix identifier_list|declaration_scope variable_decl_list|variable_decl_pattern

array_declaration ::= [declaration_scope] ('Dim'|'ReDim') IDENTIFIER [type_suffix] '(' parameters_call ')'
list_declaration ::= [declaration_scope] 'NewList' IDENTIFIER [type_suffix] '(' ')'
map_declaration ::= [declaration_scope] 'NewMap' IDENTIFIER [type_suffix] '(' ')'



////////////////////////
// Blocks
////////////////////////

// Procedure
private procedure_decl_pattern ::= [type_suffix] IDENTIFIER '(' parameters_decl ')'
procedure_declaration ::= ('DeclareC'|'Declare') procedure_decl_pattern

procedure ::= procedure_head [sep statements] sep procedure_foot

private parameters_decl_var ::= any_identifier [type_suffix]
private parameters_decl_array ::= 'Array' IDENTIFIER [type_suffix] '(' NUMBER ')'
private parameters_decl_list ::= 'List' IDENTIFIER [type_suffix] '(' ')'
private parameters_decl_map ::= 'Map' IDENTIFIER [type_suffix] '(' ')'
parameters_decl ::= (parameters_decl_var | parameters_decl_array | parameters_decl_list | parameters_decl_map) [','parameters_decl]
parameters_call ::= expression (',' expression)*

procedure_head ::= ('ProcedureCDLL' | 'ProcedureDLL' | 'ProcedureC' | 'Procedure') procedure_decl_pattern
procedurereturn ::= 'ProcedureReturn' [expression]
procedure_foot ::= 'EndProcedure'

// Macro
private macro_decl_pattern ::= [type_suffix] IDENTIFIER ['(' identifier_list ')']

macro ::= macro_head [sep statements] sep macro_foot

macro_head ::= 'Macro' macro_decl_pattern
macro_foot ::= 'EndMacro'

// With
with ::= with_head [sep statements] sep with_foot

with_head ::= 'With' identifier_or_call_chained
with_foot ::= 'EndWith'


call ::= IDENTIFIER '(' [parameters_call] ')'

// Structure
structure ::= structure_head [sep (statements|structure_union)] sep structure_foot

structure_head ::= 'Structure' IDENTIFIER ['Extends' IDENTIFIER] ['Align' (NUMBER|CONSTANT)]
structure_foot ::= 'EndStructure'

structure_union ::= structure_union_head [sep statements] sep structure_union_foot

structure_union_head ::= 'StructureUnion' IDENTIFIER
structure_union_foot ::= 'EndStructureUnion'

// Interface
interface ::= interface_head [sep statements] sep interface_foot

interface_head ::= 'Interface' IDENTIFIER ['Extends' IDENTIFIER]
interface_foot ::= 'EndInterface'

// Import
import ::= import_head [sep statements] sep import_foot

import_head ::= ('Import'|'ImportC') STRING
import_foot ::= 'EndImport'

// DataSection
datasection ::= datasection_head [sep statements] sep datasection_foot

data_list ::= CONSTANT|NUMBER|STRING [','data_list]
dataentry ::= 'Data' [type_suffix] data_list

datasection_head ::= 'DataSection'
datasection_foot ::= 'EndDataSection'

// DeclareModule
declaremodule ::= declaremodule_head [sep statements] sep declaremodule_foot

declaremodule_head ::= 'DeclareModule'
declaremodule_foot ::= 'EndDeclareModule'

// Module
definemodule ::= definemodule_head [sep statements] sep definemodule_foot

definemodule_head ::= 'Module'
definemodule_foot ::= 'EndModule'

// Enumeration
enumeration ::= enumeration_head [sep statements] sep enumeration_foot

enumeration_head ::= ('Enumeration' | 'EnumerationBinary')
enumeration_foot ::= 'EndEnumeration'


// Loops
private while ::= 'While' expression [sep statements] sep 'Wend'
private for ::= 'For' variable_decl_pattern '=' expression 'To' expression ['Step' NUMBER] [sep statements] sep 'Next' [IDENTIFIER]
private foreach ::= 'ForEach' identifier_or_call_chained [sep statements] sep 'Next'
private repeat ::= 'Repeat' [sep statements] sep ('Until' expression | 'ForEver')

loop ::= while|for|foreach|repeat

// Conditional
private condition_if ::= 'If' expression [sep statements]
private condition_elseif ::= 'ElseIf' expression [sep statements]
private condition_else ::= 'Else' [sep statements]
private condition_endif ::= 'EndIf'

private condition_case ::= ('Case' expression|'Default') [sep statements]
private condition_select ::= 'Select' expression (sep condition_case)* sep 'EndSelect'

condition ::= condition_if (sep condition_elseif)* [sep condition_else] sep condition_endif | condition_select

// Compiler Conditional
private comp_condition_if ::= 'CompilerIf' expression [sep statements]
private comp_condition_elseif ::= 'CompilerElseIf' expression [sep statements]
private comp_condition_else ::= 'CompilerElse' [sep statements]
private comp_condition_endif ::= 'CompilerEndIf'

private comp_condition_case ::= ('CompilerCase' expression|'CompilerDefault') [sep statements]
private comp_condition_select ::= 'CompilerSelect' expression (sep comp_condition_case)* sep 'CompilerEndSelect'

comp_condition ::= comp_condition_if (sep comp_condition_elseif)* [sep comp_condition_else] sep comp_condition_endif |
                   comp_condition_select

////////////////////////
// Simple Statements
////////////////////////

include ::= ('XIncludeFile'|'IncludeFile') STRING
includebinary ::= 'IncludeBinary' STRING
includepath ::= 'IncludePath' STRING
usemodule ::= 'UseModule' IDENTIFIER
unusemodule ::= 'UnuseModule' IDENTIFIER
undefinemacro ::= 'UndefineMacro' IDENTIFIER
swap ::= 'Swap' identifier_or_call_chained ',' identifier_or_call_chained
runtime ::= 'Runtime' (CONSTANT|any_identifier|procedure|enumeration)
return ::= 'Return'
restore ::= 'Restore' IDENTIFIER
read ::= 'Read' [type_suffix] IDENTIFIER
prototype ::= ('PrototypeC'|'Prototype') procedure_decl_pattern
macroexpandedcount ::= 'MacroExpandedCount'
goto ::= 'Goto' IDENTIFIER
gosub ::= 'Gosub' IDENTIFIER
fakereturn ::= 'FakeReturn'
end ::= 'End' expression
enablejs ::= 'EnableJS'
enableexplicit ::= 'EnableExplicit'
enabledebugger ::= 'EnableDebugger'
enableasm ::= 'EnableASM'
disablejs ::= 'DisableJS'
disableexplicit ::= 'DisableExplicit'
disabledebugger ::= 'DisableDebugger'
disableasm ::= 'DisableASM'
debuglevel ::= 'DebugLevel' (CONSTANT|NUMBER)
debug ::= 'Debug' expression [',' (CONSTANT|NUMBER)]
continue ::= 'Continue'
break ::= 'Break'
compilerwarning ::= 'CompilerWarning' (CONSTANT|STRING)
compilererror ::= 'CompilerError' (CONSTANT|STRING)
calldebugger ::= 'CallDebugger'

////////////////////////
// Misc
////////////////////////

private leftTokens ::= KEYWORD|OPERATOR
// private tokenTypes_ ::= COMMENT|KEYWORD|OPERATOR|STRING|CHARACTER|CONSTANT|NUMBER|IDENTIFIER|POINTER_IDENTIFIER
